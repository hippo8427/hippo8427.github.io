---
title: Weekly Paper 05
date: 2025-06-30
layout: single
---

<br>

## 📌 프로세스와 스레드란?

### 🔍 개념 정리

| 항목      | 프로세스(Process)                  | 스레드(Thread)                   |
| ------- | ------------------------------ | ----------------------------- |
| **정의**  | 실행 중인 프로그램의 인스턴스               | 프로세스 내에서 실행되는 최소 실행 단위        |
| **메모리** | 각각의 프로세스는 독립된 메모리 공간을 가짐       | 같은 프로세스의 메모리를 공유함             |
| **독립성** | 서로 독립적 → 하나가 죽어도 다른 프로세스 영향 없음 | 같은 프로세스 내에서 서로 영향을 미칠 수 있음    |
| **속도**  | 생성과 컨텍스트 스위칭이 상대적으로 느림         | 생성과 전환이 빠름                    |
| **예시**  | 크롬 브라우저 실행, 백엔드 서버 구동 등        | 탭 하나하나, 클라이언트 요청 처리용 작업 쓰레드 등 |

<br>

#### 📍 중요 포인트
* 백엔드 서버, DB, 클라우드 환경 등 대부분의 시스템이 프로세스와 스레드 구조 위에서 동작한다.
* Node.js는 단일 프로세스에서 이벤트 루프와 비동기 처리를 통해 멀티 스레드처럼 작동한다.
* Java는 기본적으로 하나의 프로세스 안에서 여러 개의 스레드 생성이 가능하다.
* 
<br>

### 🔍 멀티 프로세스 vs 멀티 스레드

| 유형          | 특징                         | 장점                  | 단점                         |
| ----------- | -------------------------- | ------------------- | -------------------------- |
| **멀티 프로세스** | 여러 개의 독립된 프로세스를 실행         | 안정성 (하나가 죽어도 영향 없음) | 자원 소모 큼, IPC(프로세스간 통신) 복잡함 |
| **멀티 스레드**  | 하나의 프로세스 안에서 여러 스레드를 병렬 실행 | 빠른 전환, 메모리 절약       | 스레드 충돌 위험, 디버깅 어려움         |



<details> <summary><strong style="font-size: 1.2em;">🔸 싱글 스레드에서도 병렬 처리가 가능한 이유</strong></summary> 
<div style="background: #f0f0f0; padding: 1em;" markdown="1">

### Node.js는 싱글 스레드 기반으로 동작하지만, 실제로는 동시에 여러 작업을 처리할 수 있다.

1. **이벤트 루프(Event Loop)**
  * JavaScript 메인 스레드는 이벤트 루프를 통해 **작업 큐(할 일 목록)** 에서 작업을 가져와 처리합니다.

  * 블로킹 없이 다음 작업으로 넘어가며, 대기 중인 **I/O (입출력)** 결과가 오면 **콜백 큐(완료 후 대기소)** 에서 다시 처리합니다.

2. **백그라운드 스레드 (libuv Thread Pool)**
  * 시간이 오래 걸리는 작업 (예: 파일 읽기, DNS, 암호화)은 메인 스레드가 직접 처리하지 않습니다.

  * 대신 **libuv(백그라운드 스레드 관리자)** 가 관리하는 스레드 풀에 위임하여 백그라운드에서 실행됩니다.

  * 작업이 끝나면 이벤트 루프에 다시 결과를 알려줘 메인 스레드가 이어서 처리합니다.

</div> 
</details> 

<br><br>

## 📌 프레임워크와 라이브러리의 차이 

### 🔍 개념 정리

| 항목        | 프레임워크(Framework)                          | 라이브러리(Library)                 |
| --------- | ----------------------------------------- | ------------------------------ |
| **역할**    | 전체 구조 제공, 제어의 주도권을 가짐                     | 특정 기능만 제공, 호출은 개발자가 직접 함       |
| **제어 흐름** | 프레임워크가 개발자의 코드를 호출 (Inversion of Control) | 개발자가 필요 시 라이브러리를 직접 호출함        |
| **예시**    | Spring, Django, Express 등                 | Lodash, NumPy, Axios, Moment 등 |
| **비유**    | 요리 레시피와 식자재를 모두 주는 셰프                     | 원하는 요리에 필요한 조미료나 도구만 제공함       |


<br>

#### 📍 실제 사용 예시 비교

```js
// 프레임워크 (Express) 요청이 들어오면 익스프레스가 코드를 실행시킴 (제어권)
import express from 'express';

const app = express();
app.get('/', (req, res) => res.send('Hello World!'));
app.listen(3000);

// 라이브러리 (Axios) 필요할 때 사용자가 작성하여 사용
import axios from 'axios';

axios.get('https://api.example.com/users')
  .then(response => {
    console.log(response.data);
  })
  .catch(error => {
    console.error(error);
  });

```
