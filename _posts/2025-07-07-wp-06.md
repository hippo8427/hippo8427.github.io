---
title: Weekly Paper 06
date: 2025-07-07
layout: single
---

<br>

## 📌 웹 서비스에서 관계형 DB를 사용하는 이유

### 🔍 개념 정리

**데이터 무결성 보장**  

* 관계형 데이터베이스는 **스키마(Schema)** 와 **제약조건(Constraints)** 을 통해 데이터의 일관성과 정확성을 유지함.<br>
  * Primary Key, Foreign Key, Unique, Not Null 등 

<br>

#### 📍 중요 포인트
* 웹 서비스는 사용자가 많고 데이터가 빠르게 늘어나므로, **데이터의 정확성과 일관성** 이 매우 중요하다.
* 관계형 데이터베이스는 트랜잭션(롤백, 커밋) 기능으로 데이터의 안정성을 보장한다.
* 잘 정의된 스키마 덕분에 데이터 구조를 명확히 설계할 수 있어, 유지보수성이 높다.

<br>

<details> <summary><strong style="font-size: 1.2em;">🔸 NoSQL과 비교해 관계형 DB를 쓰는 이유</strong></summary> 
<div style="background: #f0f0f0; padding: 1em;" markdown="1">

<br>

**관계형 DB는 특히 데이터 간의 관계가 중요한 서비스에 강력하다.**

**1. 데이터 정합성 (Integrity) 유지**
  * 관계형 DB는 **제약조건** 으로 잘못된 데이터를 방지할 수 있다.
    * 잘못된 외래키 입력, 중복된 키 방지 등

**2. 복잡한 쿼리 처리**
  * SQL을 이용해 조인(Join), 그룹핑(Group By) 등 복잡한 데이터를 한 번에 처리할 수 있다.

**3. ACID 보장**
  * 원자성(Atomicity), 일관성(Consistency), 고립성(Isolation), 지속성(Durability)을 만족시켜 금융, 결제 시스템처럼 정확성이 중요한 서비스에 적합하다.

<br>
 
| 항목                    | 설명                                                   |
| --------------------- | ---------------------------------------------------- |
| **Atomicity (원자성)**   | 트랜잭션은 반드시 **모두 성공하거나, 전부 실패** 해야 함. <br> → 중간 상태는 없음 |
| **Consistency (일관성)** | 트랜잭션 수행 전과 후에 데이터가 항상 **일관된 규칙** 을 지켜야 함.            |
| **Isolation (고립성)**   | 여러 트랜잭션이 동시에 수행돼도 **서로 간섭하지 않도록** 보호해야 함.            |
| **Durability (지속성)**  | 트랜잭션이 커밋되면, 그 결과는 **절대 사라지지 않고 보존** 되어야 함.           |

---

</div> 
</details> 

<br>

### 🔍 관계형 데이터베이스 사용 예시

| 서비스 예시             | 이유                                        |
| -------------------- | ----------------------------------------- |
| **쇼핑몰, 결제 시스템** | 주문, 결제, 재고 등 서로 연관된 데이터의 무결성이 중요하기 때문 |
| **SNS 서비스**       | 사용자, 게시글, 댓글, 친구 관계 등 다수의 연관 관계를 관리해야 하기 때문 |


<br><br>

## 📌 Primary Key 와 Foreign Key

### 🔍 개념 정리

| 항목              | Primary Key (기본키)                           | Foreign Key (외래키)                      |
| --------------- | ----------------------------------------- | ----------------------------------- |
| **역할**          | 테이블 내에서 각 행(row)을 유일하게 식별             | 다른 테이블의 기본키를 참조해 테이블 간 관계를 맺음 |
| **중복 여부**       | 중복 불가 (Unique)                            | 중복 가능 (다대일 관계에서 자주 사용됨)      |
| **NULL 여부**     | NULL 불가                                    | NULL 가능 (관계가 없는 경우 허용할 수 있음) |
| **예시**          | 회원 테이블의 user_id                          | 주문 테이블의 user_id → 회원 테이블의 user_id 참조 |

<br>

#### 📍 중요 포인트
* **Primary Key**
  * 각 행(row)을 식별하기 위한 고유 값.
  * 주로 숫자형 ID를 많이 사용 (auto_increment, sequence 등).

* **Foreign Key**
  * 두 테이블 간 연결고리 역할.
  * 데이터의 무결성을 보장 (존재하지 않는 값을 참조하지 못하도록 함).

<br>

<details> <summary><strong style="font-size: 1.2em;">🔸 Foreign Key 사용 시 주의할 점</strong></summary> 
<div style="background: #f0f0f0; padding: 1em;" markdown="1">

<br>

**Foreign Key는 데이터 정합성을 지키기 위해 반드시 고려해야 한다.**

**1. 참조 무결성 (Referential Integrity)**
  * 외래키가 참조하는 값은 반드시 상대 테이블의 Primary Key 에 존재해야 한다.
  * 예) 삭제된 회원 ID를 주문 테이블에서 계속 참조하면 안됨.

**2. 삭제/수정 시 Cascade 설정**
  * 참조 대상이 삭제되거나 수정될 때 외래키가 어떻게 반응할지 설정해야 한다.
    * ON DELETE CASCADE → 부모 데이터 삭제 시, 자식 데이터도 삭제
    * ON UPDATE CASCADE → 부모 키 변경 시, 자식 키도 자동 변경 등등

</div> 
</details> 

<br>

### 🔍 실제 예시

```prisma
model User {
  user_id  Int     @id @default(autoincrement())
  username String

  orders   Order[]
}

model Order {
  order_id Int     @id @default(autoincrement())
  user_id  Int?   // 비회원 주문까지
  amount   Decimal? //  소숫점 까지

  user     User?   @relation(fields: [user_id], references: [user_id], onDelete: Cascade)
}
```

<br>

#### 📍 실제 동작
* `orders` 테이블의 `user_id` 는 반드시 `users` 테이블에 존재하는 `user_id` 값을 가져야 한다.
* 잘못된 ID를 입력하면 에러가 발생해 데이터 오류를 막을 수 있다.
