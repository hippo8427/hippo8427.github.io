---
title: Weekly Paper 09  
date: 2025-08-18 
layout: single  
---

<br>

## 📌 REST에서 무상태성(Stateless)이란?

### 🔍 개념 정리
* **무상태성(Stateless)** 이란, 서버가 클라이언트의 상태를 저장하지 않는다는 의미입니다.  
* 즉, **클라이언트의 모든 요청은 독립적**이며, 서버는 각 요청을 이전 요청과 관계없이 별도로 처리합니다.

| 항목         | 설명 |
|------------|------|
| **특징**      | 요청 간 독립성 유지, 서버가 클라이언트 상태 저장 X |
| **장점**      | 서버 확장성 ↑ (로드 밸런싱 용이), 단순한 구조 |
| **단점**      | 클라이언트가 매 요청마다 필요한 정보를 모두 담아야 함 |
| **예시**      | 로그인 후 API 호출 시 매번 인증 토큰(JWT 등)을 포함해야 함 |

<br>

#### 📍 중요 포인트
* 무상태성이기 때문에 서버는 요청 사이의 세션 정보를 보관하지 않음.
* 인증은 주로 **토큰 기반(JWT, OAuth 등)** 으로 처리.
* 이 덕분에 서버 확장이 쉬워지고, 장애가 발생해도 다른 서버로 요청을 쉽게 분산할 수 있음.

```js
// 클라이언트가 매 요청마다 토큰을 포함해야 하는 예시
fetch("https://api.example.com/user/profile", {
  headers: {
    Authorization: "Bearer <JWT_TOKEN>"
  }
})
  .then(res => res.json())
  .then(data => console.log(data));
```

---

<br>

## 📌 CORS란?

### 🔍 개념 정리
* **CORS (Cross-Origin Resource Sharing)** 는 브라우저에서 보안 상의 이유로 다른 출처(Origin)의 리소스를 요청할 때 적용되는 정책입니다.
* **Origin(출처)** = `프로토콜 + 도메인 + 포트`  
  (예: `https://example.com:443`)

  <br>

| 항목         | 설명 |
|------------|------|
| **필요성**    | 보안상의 이유로 기본적으로 브라우저는 다른 출처 요청을 차단 |
| **동작 방식** | 서버가 허용할 출처를 `Access-Control-Allow-Origin` 헤더로 알려줌 |
| **예시**      | `http://localhost:3000` → `http://api.example.com` 요청 시 CORS 체크 발생 |

<br>

#### 📍 cors 흐름
1. 프론트엔드가 브라우저를 통해서 서버에 요청을 보냄
2. 브라우저가 요청을 보낼 때, 출처[origin(프로토콜 + 도메인 + 포트)] 을 비교한 후 서로 다르면 CORS 정책 적용 대상으로 인식
3. 요청 방식이나 헤더가 단순하지 않으면, 브라우저는 서버에 사전 요청(Preflight Request) 을 OPTIONS 메서드로 보냄
4. 서버의 응답 헤더에 해당 OPTIONS 요청에 대한 허용 정책을 담은 응답을 포함시킴
   - `Access-Control-Allow-Origin`
   - `Access-Control-Allow-Methods`
   - `Access-Control-Allow-Headers`
4. 정책을 보고 브라우저가 통과시킬지 말지 결정함

<br>

```js
// Express에서 CORS 허용 예시
import express from 'express';
import cors from 'cors';

const app = express();

// 모든 출처 허용
app.use(cors());

// 특정 출처만 허용
// app.use(cors({ origin: 'http://localhost:3000' }));

app.get('/data', (req, res) => {
  res.json({ message: 'CORS 허용 완료' });
});

app.listen(4000);
```

* cors 를 우회하고싶다면 프록시 서버를 사용하면 된다.
